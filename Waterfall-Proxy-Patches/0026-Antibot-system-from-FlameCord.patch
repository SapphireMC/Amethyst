From d4ae72343bc07c247da9f04b2d898d05f2040933 Mon Sep 17 00:00:00 2001
From: DenaryDev <denaryplanet@gmail.com>
Date: Sun, 6 Mar 2022 02:47:48 +0500
Subject: [PATCH] Antibot system from FlameCord


diff --git a/flame/pom.xml b/flame/pom.xml
index 4403f191..da5bc9be 100644
--- a/flame/pom.xml
+++ b/flame/pom.xml
@@ -31,5 +31,10 @@
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>com.maxmind.db</groupId>
+            <artifactId>maxmind-db</artifactId>
+            <version>2.0.0</version>
+        </dependency>
     </dependencies>
 </project>
\ No newline at end of file
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/Amethyst.java b/flame/src/main/java/io/sapphiremc/amethyst/Amethyst.java
index 934c0ccf..076515a7 100644
--- a/flame/src/main/java/io/sapphiremc/amethyst/Amethyst.java
+++ b/flame/src/main/java/io/sapphiremc/amethyst/Amethyst.java
@@ -1,6 +1,9 @@
 package io.sapphiremc.amethyst;
 
+import io.sapphiremc.amethyst.antibot.CheckManager;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
 import io.sapphiremc.amethyst.conf.AmethystConfig;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
 import io.sapphiremc.amethyst.conf.MessagesConfig;
 import java.util.logging.Logger;
 import lombok.Getter;
@@ -40,6 +43,12 @@ public class Amethyst {
      */
     @Getter
     private AmethystConfig config;
+    /**
+     * Amethyst Antibot config.
+     * @see AntibotConfig
+     */
+    @Getter
+    private AntibotConfig antibotConfig;
     /**
      * Amethyst messages config.
      * @see MessagesConfig
@@ -47,6 +56,17 @@ public class Amethyst {
     @Getter
     private MessagesConfig messages;
 
+    /**
+     *
+     */
+    @Getter
+    private AddressDataManager addressDataManager;
+    /**
+     *
+     */
+    @Getter
+    private CheckManager checkManager;
+
     /**
      * This method is used by the proxy to initialize this
      * Doesn't use this if you don't know what you are doing
@@ -54,7 +74,13 @@ public class Amethyst {
     public void load(Logger logger) {
         this.provider = ConfigurationProvider.getProvider(YamlConfiguration.class);
         this.logger = logger;
+
         this.config = new AmethystConfig(provider);
+        this.antibotConfig = new AntibotConfig(provider);
         this.messages = new MessagesConfig(provider);
+
+        this.addressDataManager = new AddressDataManager();
+        if (this.checkManager != null) this.checkManager.unload();
+        this.checkManager = new CheckManager(addressDataManager, antibotConfig);
     }
 }
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/CheckManager.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/CheckManager.java
new file mode 100644
index 00000000..93c39aee
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/CheckManager.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot;
+
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.antibot.checks.AccountsCheck;
+import io.sapphiremc.amethyst.antibot.checks.CountryCheck;
+import io.sapphiremc.amethyst.antibot.checks.FastChatCheck;
+import io.sapphiremc.amethyst.antibot.checks.FirewallCheck;
+import io.sapphiremc.amethyst.antibot.checks.NicknameCheck;
+import io.sapphiremc.amethyst.antibot.checks.PasswordCheck;
+import io.sapphiremc.amethyst.antibot.checks.RateLimitCheck;
+import io.sapphiremc.amethyst.antibot.checks.ReconnectCheck;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.Getter;
+
+@Getter
+public class CheckManager {
+    private final AccountsCheck accountsCheck;
+    private final CountryCheck countryCheck;
+    private final FastChatCheck fastChatCheck;
+    private final FirewallCheck firewallCheck;
+    private final NicknameCheck nicknameCheck;
+    private final PasswordCheck passwordCheck;
+    private final RateLimitCheck rateLimitCheck;
+    private final ReconnectCheck reconnectCheck;
+
+    public CheckManager(final AddressDataManager dataManager, final AntibotConfig config) {
+        this.accountsCheck = new AccountsCheck(dataManager, config);
+        this.countryCheck = new CountryCheck(dataManager, config);
+        this.fastChatCheck = new FastChatCheck(dataManager, config);
+        this.firewallCheck = new FirewallCheck(dataManager, config);
+        this.nicknameCheck = new NicknameCheck(dataManager, config);
+        this.passwordCheck = new PasswordCheck(dataManager, config);
+        this.rateLimitCheck = new RateLimitCheck(dataManager, config);
+        this.reconnectCheck = new ReconnectCheck(dataManager, config);
+
+        this.countryCheck.load();
+        this.firewallCheck.load();
+    }
+
+    public void unload() {
+        this.countryCheck.unload();
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressData.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressData.java
new file mode 100644
index 00000000..a149cdc5
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressData.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.address;
+
+import io.sapphiremc.amethyst.Amethyst;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+import lombok.Setter;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashSet;
+
+@RequiredArgsConstructor
+public class AddressData {
+
+    @Getter
+    private final Collection<String> nicknames = new HashSet<>();
+
+    @Getter
+    private final String hostString;
+    @Getter
+    private String lastNickname = "";
+    @Getter
+    @Setter
+    private String country = null;
+    private long lastPing = 0;
+    @Getter
+    private long penUltimateConnection = 0;
+    @Getter
+    private long lastConnection = 0;
+    private long lastFirewall = 0;
+    private int pingsSecond = 0;
+    @Getter
+    private int totalPings = 0;
+    private int connectionsSecond = 0;
+    @Getter
+    @Setter
+    private int totalConnections = 0;
+
+    public void addNickname(final String nickname) {
+        if (!lastNickname.equals(nickname)) {
+            this.lastNickname = nickname;
+            this.totalConnections = 1;
+        }
+
+        if (!this.nicknames.contains(nickname)) {
+            this.nicknames.add(nickname);
+        }
+    }
+
+    public long getTimeSincePenUltimateConnection() {
+        return System.currentTimeMillis() - penUltimateConnection;
+    }
+
+    public long getTimeSinceLastConnection() {
+        return System.currentTimeMillis() - lastConnection;
+    }
+
+    private void updatePingsSecond() {
+        if (System.currentTimeMillis() - lastPing >= 1000) {
+            pingsSecond = 0;
+        }
+    }
+
+    public int getPingsSecond() {
+        updatePingsSecond();
+        return pingsSecond;
+    }
+
+    public void addPing() {
+        updatePingsSecond();
+        lastPing = System.currentTimeMillis();
+        pingsSecond++;
+        totalPings++;
+    }
+
+    private void updateConnectionsSecond() {
+        if (System.currentTimeMillis() - lastConnection >= 1000) {
+            connectionsSecond = 0;
+        }
+    }
+
+    public int getConnectionsSecond() {
+        updateConnectionsSecond();
+        return connectionsSecond;
+    }
+
+    public void addConnection() {
+        final long currentTime = System.currentTimeMillis();
+
+        updateConnectionsSecond();
+        penUltimateConnection = lastConnection == 0 ? currentTime : lastConnection;
+        lastConnection = currentTime;
+        connectionsSecond++;
+        totalConnections++;
+    }
+
+    public boolean isFirewalled() {
+        return System.currentTimeMillis() - lastFirewall < Amethyst.getInstance().getAntibotConfig().firewallExpire * 1000L;
+    }
+
+    public void firewall() {
+        if ( !hostString.equals("127.0.0.1") && Amethyst.getInstance().getAntibotConfig().firewallIpset )
+        {
+            final Runtime runtime = Runtime.getRuntime();
+
+            try {
+                runtime.exec("ipset add amethyst_blacklist " + getHostString());
+            } catch (IOException ex) {
+                ex.printStackTrace();
+            }
+        }
+
+        this.lastFirewall = System.currentTimeMillis();
+    }
+
+    public boolean hasNickname(final String nickname) {
+        return nicknames.contains(nickname);
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressDataManager.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressDataManager.java
new file mode 100644
index 00000000..c971c858
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/address/AddressDataManager.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.address;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AddressDataManager {
+    protected final Map<String, AddressData> addresses = new HashMap<>();
+
+    public AddressData getAddressData(SocketAddress address) {
+        String host = ((InetSocketAddress) address).getHostName();
+
+        if (addresses.containsKey(host)) {
+            return addresses.get(host);
+        } else {
+            AddressData data = new AddressData(host);
+
+            addresses.put(host, data);
+
+            return data;
+        }
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/AccountsCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/AccountsCheck.java
new file mode 100644
index 00000000..f97243a1
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/AccountsCheck.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+import java.util.Collection;
+
+@RequiredArgsConstructor
+public class AccountsCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    public boolean check(final SocketAddress address, final String nickname) {
+        if (config.accountsEnabled) {
+            final AddressData data = dataManager.getAddressData(address);
+            final Collection<String> nicknames = data.getNicknames();
+
+            if (nicknames.size() > config.accountsLimit) {
+                nicknames.remove(nickname);
+
+                if (config.accountsFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/CountryCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/CountryCheck.java
new file mode 100644
index 00000000..d798a185
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/CountryCheck.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import com.maxmind.db.CHMCache;
+import com.maxmind.db.MaxMindDbConstructor;
+import com.maxmind.db.MaxMindDbParameter;
+import com.maxmind.db.Reader;
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.net.URL;
+import java.nio.file.Files;
+
+@RequiredArgsConstructor
+public class CountryCheck {
+
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+    private Reader maxMindReader;
+
+    public void download(final URL url, final File file) throws IOException {
+        try (InputStream in = url.openStream()) {
+            Files.copy(in, file.toPath());
+        }
+    }
+
+    public void load() {
+        final File file = new File("GeoLite2-Country.mmdb");
+
+        try {
+            if (!file.exists()) {
+                System.out.println("Starting download of MaxMindDB (This will take some seconds...)");
+                download(new URL("https://git.io/GeoLite2-Country.mmdb"), file);
+            }
+
+            this.maxMindReader = new Reader(file, new CHMCache());
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public void unload() {
+        try {
+            if (this.maxMindReader != null) {
+                this.maxMindReader.close();
+            }
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private boolean isBlacklisted(final String isoCode) {
+        for (String blacklisted : config.countryBlacklist) {
+            if (isoCode.contains(blacklisted)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private String getIsoCode(final InetAddress address) {
+        try {
+            final LookupResult result = maxMindReader.get(address, LookupResult.class);
+
+            if (result == null) {
+                return "LOCAL";
+            } else {
+                final Country country = result.getCountry();
+                return country.getIsoCode();
+            }
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+
+        return null;
+    }
+
+    public boolean check(final SocketAddress address) {
+        if (config.countryEnabled) {
+            final AddressData data = dataManager.getAddressData(address);
+            final String addressCountry = data.getCountry();
+            final String country;
+
+            if (addressCountry != null) {
+                country = addressCountry;
+            } else {
+                country = getIsoCode(((InetSocketAddress) address).getAddress());
+                data.setCountry(country);
+            }
+
+            if (country != null && isBlacklisted(country)) {
+                if (config.countryFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static class LookupResult {
+        @Getter
+        private final Country country;
+
+        @MaxMindDbConstructor
+        public LookupResult(@MaxMindDbParameter(name = "country") final Country country) {
+            this.country = country;
+        }
+    }
+
+    public static class Country {
+        @Getter
+        private final String isoCode;
+
+        @MaxMindDbConstructor
+        public Country(@MaxMindDbParameter(name = "iso_code") final String isoCode) {
+            this.isoCode = isoCode;
+        }
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FastChatCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FastChatCheck.java
new file mode 100644
index 00000000..bb7bfe9a
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FastChatCheck.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class FastChatCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    public boolean check(final SocketAddress address) {
+        if (config.fastChatEnabled) {
+            final AddressData data = dataManager.getAddressData(address);
+
+            if (data.getTimeSinceLastConnection() <= config.fastChatTime) {
+                if (config.fastChatFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FirewallCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FirewallCheck.java
new file mode 100644
index 00000000..67b9f32c
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/FirewallCheck.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.io.IOException;
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class FirewallCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    public void load() {
+        if (config.firewallIpset) {
+            final Runtime runtime = Runtime.getRuntime();
+
+            try {
+                runtime.exec("iptables -D INPUT -p tcp -m set --match-set amethyst_blacklist src -j DROP");
+                runtime.exec("ipset flush flamecord_blacklist");
+                runtime.exec("ipset destroy flamecord_blacklist");
+                runtime.exec("ipset create amethyst_blacklist hash:ip timeout " + config.firewallExpire);
+                runtime.exec("iptables -I INPUT -p tcp -m set --match-set amethyst_blacklist src -j DROP");
+            } catch (IOException ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    public boolean check(final SocketAddress address) {
+        if (config.firewallEnabled)
+            return dataManager.getAddressData(address).isFirewalled();
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/NicknameCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/NicknameCheck.java
new file mode 100644
index 00000000..de20cfea
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/NicknameCheck.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class NicknameCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    private boolean isBlacklisted(final String nickname) {
+        for (String blacklisted : config.nicknameBlacklist) {
+            if (nickname.toLowerCase().contains(blacklisted)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean check(final SocketAddress address) {
+        if (config.nicknameEnabled) {
+            final AddressData data = dataManager.getAddressData(address);
+            final String nickname = data.getLastNickname();
+
+            if (isBlacklisted(nickname)) {
+                if (config.nicknameFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/PasswordCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/PasswordCheck.java
new file mode 100644
index 00000000..7c66ff20
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/PasswordCheck.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class PasswordCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    private String lastNickname = "";
+    private String lastPassword = "";
+    @Getter
+    private int repeatCount = 0;
+
+    private void updatePassword(final String nickname, final String password) {
+        if (!nickname.equals(lastNickname)) {
+            if (password.equals(lastPassword)) {
+                if (repeatCount < config.passwordLimit) {
+                    repeatCount++;
+                }
+            } else if (repeatCount > 0) {
+                repeatCount--;
+            }
+        }
+
+        lastNickname = nickname;
+        lastPassword = password;
+    }
+
+    public boolean check(final SocketAddress address, final String passwordMessage) {
+        if (config.passwordEnabled &&
+                (passwordMessage.contains("/login ") || passwordMessage.contains("/l ")
+                || passwordMessage.contains("/register ") || passwordMessage.contains("/reg "))) {
+            final AddressData data = dataManager.getAddressData(address);
+            final String nickname = data.getLastNickname();
+            final String password = passwordMessage.split(" ")[1];
+
+            updatePassword(nickname, password);
+
+            if (repeatCount >= config.passwordLimit) {
+                if (config.passwordFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/RateLimitCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/RateLimitCheck.java
new file mode 100644
index 00000000..0f87d495
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/RateLimitCheck.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class RateLimitCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+
+    public boolean check(final SocketAddress address) {
+        if (config.rateLimitEnabled) {
+            final AddressData data = dataManager.getAddressData(address);
+
+            if (data.getConnectionsSecond() >= config.rateLimitConnectionsPerSecond || data.getPingsSecond() >= config.rateLimitPingsPerSecond) {
+                if (config.rateLimitFirewall) data.firewall();
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/ReconnectCheck.java b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/ReconnectCheck.java
new file mode 100644
index 00000000..80c61d8b
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/antibot/checks/ReconnectCheck.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.antibot.checks;
+
+import io.sapphiremc.amethyst.antibot.address.AddressData;
+import io.sapphiremc.amethyst.antibot.address.AddressDataManager;
+import io.sapphiremc.amethyst.conf.AntibotConfig;
+import lombok.RequiredArgsConstructor;
+
+import java.net.SocketAddress;
+
+@RequiredArgsConstructor
+public class ReconnectCheck {
+    private final AddressDataManager dataManager;
+    private final AntibotConfig config;
+    private int connections = 0;
+    private long lastConnection = 0;
+
+    public boolean check(final SocketAddress address) {
+        if (config.reconnectEnabled) {
+            final long currentTime = System.currentTimeMillis();
+
+            if (currentTime - lastConnection > config.reconnectConnectionThresholdLimit) {
+                lastConnection = currentTime;
+                connections = 0;
+            }
+
+            if (++connections > config.reconnectConnectionThreshold) {
+                final AddressData data = dataManager.getAddressData(address);
+                final boolean needsAttempts = data.getTotalConnections() < config.reconnectAttempts || data.getTotalPings() < config.reconnectPings;
+                final boolean tooSlow = data.getTimeSincePenUltimateConnection() > config.reconnectMaxTime;
+
+                if (tooSlow) {
+                    data.setTotalConnections(0);
+                    return false;
+                } else {
+                    return needsAttempts;
+                }
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/conf/AntibotConfig.java b/flame/src/main/java/io/sapphiremc/amethyst/conf/AntibotConfig.java
new file mode 100644
index 00000000..dc21bf8d
--- /dev/null
+++ b/flame/src/main/java/io/sapphiremc/amethyst/conf/AntibotConfig.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2022 DenaryDev
+ *
+ * Use of this source code is governed by an MIT-style
+ * license that can be found in the LICENSE file or at
+ * https://opensource.org/licenses/MIT.
+ */
+package io.sapphiremc.amethyst.conf;
+
+import net.md_5.bungee.config.ConfigurationProvider;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Antibot configuration class
+ * Use this only to get parameter values!
+ */
+public class AntibotConfig extends AbstractYamlConfig {
+
+    public boolean accountsEnabled = true;
+    public boolean accountsLog = true;
+    public boolean accountsFirewall = true;
+    public int accountsLimit = 3;
+
+    public boolean countryEnabled = true;
+    public boolean countryLog = true;
+    public boolean countryFirewall = true;
+    public List<String> countryBlacklist = Arrays.asList("US", "UA");
+
+    public boolean fastChatEnabled = true;
+    public boolean fastChatLog = true;
+    public boolean fastChatFirewall = true;
+    public int fastChatTime = 1000;
+
+    public boolean firewallEnabled = true;
+    public boolean firewallLog = true;
+    public boolean firewallIpset = false;
+    public int firewallExpire = 60;
+    public List<String> firewallPackets = Arrays.asList("BadPacketException", "QuietException", "IllegalStateConfig", "FastException");
+
+    public boolean nicknameEnabled = true;
+    public boolean nicknameLog = true;
+    public boolean nicknameFirewall = true;
+    public List<String> nicknameBlacklist = Arrays.asList("mcstorm", "mcdown", "mcbot", "theresa_bot", "dropbot", "kingbot");
+
+    public boolean passwordEnabled = true;
+    public boolean passwordLog = true;
+    public boolean passwordFirewall = true;
+    public int passwordLimit = 3;
+
+    public boolean rateLimitEnabled = true;
+    public boolean rateLimitLog = true;
+    public boolean rateLimitFirewall = true;
+    public int rateLimitConnectionsPerSecond = 3;
+    public int rateLimitPingsPerSecond = 8;
+
+    public boolean reconnectEnabled = true;
+    public boolean reconnectLog = true;
+    public int reconnectAttempts = 2;
+    public int reconnectPings = 0;
+    public int reconnectMaxTime = 10000;
+    public int reconnectConnectionThreshold = 1;
+    public int reconnectConnectionThresholdLimit = 8000;
+
+    public AntibotConfig(ConfigurationProvider provider) {
+        super(provider, "antibot.yml");
+        init();
+        save();
+    }
+
+    @Override
+    protected void loadContent() {
+        this.accountsEnabled = getBoolean("accounts.enabled", this.accountsEnabled);
+        this.accountsLog = getBoolean("accounts.log", this.accountsLog);
+        this.accountsFirewall = getBoolean("accounts.firewall", this.accountsFirewall);
+        this.accountsLimit = getInt("accounts.limit", this.accountsLimit);
+
+        this.countryEnabled = getBoolean("country.enabled", this.countryEnabled);
+        this.countryLog = getBoolean("country.log", this.countryLog);
+        this.countryFirewall = getBoolean("country.firewall", this.countryFirewall);
+        this.countryBlacklist = getStringList("country.blacklist", this.countryBlacklist);
+
+        this.fastChatEnabled = getBoolean("fast-chat.enabled", this.fastChatEnabled);
+        this.fastChatLog = getBoolean("accounts.log", this.fastChatLog);
+        this.fastChatFirewall = getBoolean("fast-chat.firewall", this.fastChatFirewall);
+        this.fastChatTime = getInt("fast-chat.time", this.fastChatTime);
+
+        this.firewallEnabled = getBoolean("firewall.enabled", this.firewallEnabled);
+        this.firewallLog = getBoolean("accounts.log", this.firewallLog);
+        this.firewallIpset = getBoolean("firewall.ipset", this.firewallIpset);
+        this.firewallExpire = getInt("firewall.expire", this.firewallExpire);
+        this.firewallPackets = getStringList("firewall.packets", this.firewallPackets);
+
+        this.nicknameEnabled = getBoolean("nickname.enabled", this.nicknameEnabled);
+        this.nicknameLog = getBoolean("nickname.log", this.nicknameLog);
+        this.nicknameFirewall = getBoolean("nickname.firewall", this.nicknameFirewall);
+        this.nicknameBlacklist = getStringList("nickname.blacklist", this.nicknameBlacklist);
+
+        this.passwordEnabled = getBoolean("password.enabled", this.passwordEnabled);
+        this.passwordLog = getBoolean("password.log", this.passwordLog);
+        this.passwordFirewall = getBoolean("password.firewall", this.passwordFirewall);
+        this.passwordLimit = getInt("password.limit", this.passwordLimit);
+
+        this.rateLimitEnabled = getBoolean("rate-limit.enabled", this.rateLimitEnabled);
+        this.rateLimitLog = getBoolean("rate-limit.log", this.rateLimitLog);
+        this.rateLimitFirewall = getBoolean("rate-limit.firewall", this.rateLimitFirewall);
+        this.rateLimitConnectionsPerSecond = getInt("rate-limit.per-second.connections", this.rateLimitConnectionsPerSecond);
+        this.rateLimitPingsPerSecond = getInt("rate-limit.per-second.pings", this.rateLimitPingsPerSecond);
+
+        this.reconnectEnabled = getBoolean("reconnect.enabled", this.reconnectEnabled);
+        this.reconnectLog = getBoolean("reconnect.log", this.reconnectLog);
+        this.reconnectAttempts = getInt("reconnect.attempts", this.reconnectAttempts);
+        this.reconnectPings = getInt("reconnect.pings", this.reconnectPings);
+        this.reconnectMaxTime = getInt("reconnect.max-time", this.reconnectMaxTime);
+        this.reconnectConnectionThreshold = getInt("reconnect.connection.threshold", this.reconnectConnectionThreshold);
+        this.reconnectConnectionThresholdLimit = getInt("reconnect.connection.threshold-limit", this.reconnectConnectionThresholdLimit);
+    }
+}
diff --git a/flame/src/main/java/io/sapphiremc/amethyst/conf/MessagesConfig.java b/flame/src/main/java/io/sapphiremc/amethyst/conf/MessagesConfig.java
index d4f1309a..39b35422 100644
--- a/flame/src/main/java/io/sapphiremc/amethyst/conf/MessagesConfig.java
+++ b/flame/src/main/java/io/sapphiremc/amethyst/conf/MessagesConfig.java
@@ -42,6 +42,15 @@ public class MessagesConfig extends AbstractYamlConfig {
         formattedMessages.put("server_list", ChatColor.translateAlternateColorCodes('&', getString("command.server.available", "&6You may connect to the following servers at this time: ")));
         formattedMessages.put("click_to_connect", ChatColor.translateAlternateColorCodes('&', getString("command.server.hover", "{0} player(-s) online\nClick to connect to this server")));
 
+        formattedMessages.put("antibot_account", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.accounts", "&cYou have too many accounts! ({0})")));
+        formattedMessages.put("antibot_country", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.country", "&cYour country is blacklisted! ({0})")));
+        formattedMessages.put("antibot_fast-chat", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.fast-chat", "&cYou are chatting too fast!")));
+        formattedMessages.put("antibot_firewall", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.firewall", "&cYou are blocked from this server!")));
+        formattedMessages.put("antibot_nickname", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.nickname", "&cYour nickname was detected as bot! ({0})")));
+        formattedMessages.put("antibot_password", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.password", "&cYour password is used by other players! ({0})")));
+        formattedMessages.put("antibot_rate-limit", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.rate-limit", "&cYou are connecting too fast! ({0})")));
+        formattedMessages.put("antibot_reconnect", ChatColor.translateAlternateColorCodes('&', getString("event.antibot.reconnect", "&cReconnect {0} more times to enter!")));
+
         formattedMessages.put("fallback_kick", ChatColor.translateAlternateColorCodes('&', getString("event.fallback.kick", "&cCould not connect to a default or fallback server. Incorrectly configured address/port/firewall? {0}")));
         formattedMessages.put("fallback_kick_not_found", ChatColor.translateAlternateColorCodes('&', getString("event.fallback.reason.not-found", "&cThe server you were on was not found on reload")));
         formattedMessages.put("fallback_lobby", ChatColor.translateAlternateColorCodes('&', getString("event.fallback.lobby", "&cCould not connect to target server, you have been moved to a fallback server.")));
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index f3b04379..b91caa6f 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -3,6 +3,8 @@ package net.md_5.bungee.connection;
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.gson.Gson;
+import io.sapphiremc.amethyst.antibot.CheckManager;
+import io.sapphiremc.amethyst.antibot.address.AddressData;
 import java.math.BigInteger;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
@@ -367,6 +369,11 @@ public class InitialHandler extends PacketHandler implements PendingConnection
 
         bungee.getPluginManager().callEvent( new PlayerHandshakeEvent( InitialHandler.this, handshake ) );
 
+        // Amethyst start - Antibot system
+        AddressData data = Amethyst.getInstance().getAddressDataManager().getAddressData( ch.getRemoteAddress() );
+        CheckManager checkManager = Amethyst.getInstance().getCheckManager();
+        // Amethyst end
+
         switch ( handshake.getRequestedProtocol() )
         {
             case 1:
@@ -377,6 +384,20 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 }
                 thisState = State.STATUS;
                 ch.setProtocol( Protocol.STATUS );
+
+                // Amethyst start - Antibot system
+                data.addPing();
+
+                if ( checkManager.getRateLimitCheck().check( ch.getRemoteAddress() ) )
+                {
+                    if ( Amethyst.getInstance().getAntibotConfig().rateLimitLog )
+                    {
+                        bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] is pinging too fast", ch.getRemoteAddress() );
+                    }
+                    disconnect( bungee.getTranslation( "antibot_rate-limit", data.getPingsSecond() ) );
+                    return;
+                }
+                // Amethyst end
                 break;
             case 2:
                 // Login
@@ -387,6 +408,20 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 thisState = State.USERNAME;
                 ch.setProtocol( Protocol.LOGIN );
 
+                // Amethyst start - Antibot system
+                data.addConnection();
+
+                if ( checkManager.getRateLimitCheck().check( ch.getRemoteAddress() ) )
+                {
+                    if ( Amethyst.getInstance().getAntibotConfig().rateLimitLog )
+                    {
+                        bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] is connecting too fast", ch.getRemoteAddress() );
+                    }
+                    disconnect( bungee.getTranslation( "antibot_rate-limit", data.getConnectionsSecond() ) );
+                    return;
+                }
+                // Amethyst end
+
                 if ( !ProtocolConstants.SUPPORTED_VERSION_IDS.contains( handshake.getProtocolVersion() ) )
                 {
                     if ( handshake.getProtocolVersion() > bungee.getProtocolVersion() )
@@ -451,6 +486,55 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             return;
         }
 
+        // Amethyst start - Antibot system
+        AddressData data = Amethyst.getInstance().getAddressDataManager().getAddressData( ch.getRemoteAddress() );
+        CheckManager checkManager = Amethyst.getInstance().getCheckManager();
+        String nickname = loginRequest.getData();
+
+        data.addNickname( loginRequest.getData() );
+
+        // Check account
+        if ( checkManager.getAccountsCheck().check( ch.getRemoteAddress(), nickname ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().accountsLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] has too many accounts", ch.getRemoteAddress() );
+            }
+            disconnect( bungee.getTranslation( "antibot_accounts", data.getNicknames().size() ) );
+            return;
+        }
+        // Check nickname
+        if ( checkManager.getNicknameCheck().check( ch.getRemoteAddress() ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().nicknameLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] has a blacklisted nickname", ch.getRemoteAddress() );
+            }
+            disconnect( bungee.getTranslation( "antibot_nickname", loginRequest.getData() ) );
+            return;
+        }
+        // Check reconnect
+        if ( checkManager.getReconnectCheck().check( ch.getRemoteAddress() ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().reconnectLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] has to reconnect to join", ch.getRemoteAddress() );
+            }
+            disconnect( bungee.getTranslation( "antibot_reconnect", Amethyst.getInstance().getAntibotConfig().reconnectAttempts - data.getTotalConnections()));
+            return;
+        }
+        // Check country
+        if ( checkManager.getCountryCheck().check( ch.getRemoteAddress() ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().countryLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] has his country blocked from the server", ch.getRemoteAddress() );
+            }
+            disconnect( bungee.getTranslation( "antibot_country", data.getCountry() ) );
+            return;
+        }
+        // Amethyst end
+
         // If offline mode and they are already on, don't allow connect
         // We can just check by UUID here as names are based on UUID
         if ( !isOnlineMode() && bungee.getPlayer( getUniqueId() ) != null )
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 6240204e..99657d3d 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -5,9 +5,14 @@ import com.mojang.brigadier.context.StringRange;
 import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
 import io.netty.channel.Channel;
+import io.sapphiremc.amethyst.Amethyst;
+import io.sapphiremc.amethyst.antibot.CheckManager;
+import io.sapphiremc.amethyst.antibot.address.AddressData;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.logging.Level;
+
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.ServerConnection.KeepAliveData;
 import net.md_5.bungee.UserConnection;
@@ -187,6 +192,31 @@ public class UpstreamBridge extends PacketHandler
         }
         Preconditions.checkArgument(!empty, "Chat message is empty");
 
+        // Amethyst start - Antibot system
+        CheckManager checkManager = Amethyst.getInstance().getCheckManager();
+
+        // Check chat
+        if ( checkManager.getFastChatCheck().check( con.getCh().getRemoteAddress() ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().fastChatLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] is chatting too fast", con.getCh().getRemoteAddress() );
+            }
+            con.disconnect( bungee.getTranslation( "antibot_fast-chat" ) );
+            throw CancelSendSignal.INSTANCE;
+        }
+        // Check password
+        if ( checkManager.getPasswordCheck().check( con.getCh().getRemoteAddress(), message ) )
+        {
+            if ( Amethyst.getInstance().getAntibotConfig().passwordLog )
+            {
+                bungee.getLogger().log( Level.INFO, "[AntiBot] [{0}] has entered a repeated password", con.getCh().getRemoteAddress() );
+            }
+            con.disconnect( bungee.getTranslation( "antibot_password", checkManager.getPasswordCheck().getRepeatCount() ) );
+            throw CancelSendSignal.INSTANCE;
+        }
+        // Amethyst end
+
         ChatEvent chatEvent = new ChatEvent( con, con.getServer(), message );
         if ( !bungee.getPluginManager().callEvent( chatEvent ).isCancelled() )
         {
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
index eacc9ae0..4c4e3b49 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
@@ -152,6 +152,14 @@ public class HandlerBoss extends ChannelInboundHandlerAdapter
         {
             boolean logExceptions = !( handler instanceof PingHandler ) && Amethyst.getInstance().getConfig().logExceptions; // Amethyst - Option to fully disable exceptions logging.
 
+            // Amethyst start - Antibot system
+            if ( Amethyst.getInstance().getAntibotConfig().firewallPackets.contains( cause.getClass().getName() ) )
+            {
+                Amethyst.getInstance().getAddressDataManager().getAddressData( ctx.channel().remoteAddress() ).firewall();
+                ProxyServer.getInstance().getLogger().log( Level.INFO, "[AntiBot] [{0}] was firewalled because of " + cause.getClass().getName(), ctx.channel().remoteAddress() );
+            }
+            // Amethyst end
+
             if ( logExceptions )
             {
                 if ( cause instanceof ReadTimeoutException )
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
index 45043b83..02ea4c8d 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
@@ -59,6 +59,18 @@ public class PipelineUtils
         {
             SocketAddress remoteAddress = ( ch.remoteAddress() == null ) ? ch.parent().localAddress() : ch.remoteAddress();
 
+            // Amethyst start - Antibot system
+            if ( Amethyst.getInstance().getCheckManager().getFirewallCheck().check( ch.remoteAddress() ) )
+            {
+                if ( Amethyst.getInstance().getAntibotConfig().firewallLog )
+                {
+                    BungeeCord.getInstance().getLogger().log( Level.INFO, "[AntiBot] [{0}] is firewalled from the server", ch.remoteAddress() );
+                }
+                ch.close();
+                return;
+            }
+            // Amethyst end
+
             if ( BungeeCord.getInstance().getConnectionThrottle() != null && BungeeCord.getInstance().getConnectionThrottle().throttle( remoteAddress ) )
             {
                 ch.close();
-- 
2.37.1.windows.1

